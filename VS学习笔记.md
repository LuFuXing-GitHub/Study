**注意：在动态库、静态库的创建中，由于pch预编译头的存在，虽然不用显式的包含新的头文件，在静态库生成里没什么问题；但是在动态库生成中，如果你不显式包含头文件，编译不会报错，但就是一直生成不了对应的.dll静态库文件**

**注意：在一个解决方案中新建了多个其他项目后，一定要及时设定正确的启动项目，如果启动项目为某个库(.dll .lib)都无法正常启动，及时代码编译通过、且并没有任何问题。**

**注意：在一个重大工程中，一个项目通常会依赖另一个或者多个项目的库，此时就存在某些库的函数名或者变量名一致，就会起冲突，这时在编译的时候就会报错：**
**错误	C2375	“bubbleSort”: 重定义；不同的链接	dllAndLib**

**表明dllAndLib项目中依赖的库中有两个或多个bubbleSort函数，此时就需要修改某个库的源码进行修改或加上某个名字空间，予以区分**		

VS中包含某个头文件只需要包含他的正确路径即可，无需添加到VS项目中

```C++
例如，当前我需要使用处理xml文件的头文件，而我把头文件放在了当前程序目录的上一级下：
#include "../Include/tinyxml.h"
操作完就可以了，而不需要显式的将其添加进来
```

VS包含某个cpp源文件则需要将文件添加进来

```C++
例如，当前我已经包含了这个头文件#include "../Include/tinyxml.h"，但是头文件内只有函数的声明，没有函数的实现(定义)，现在如果我编译就会报错：无法解析的外部符号…… 这是因为编译器找不到该函数的实现，所以将cpp文件添加进来即可
```

以上使用方法为使用源文件的方式使用某些别人已经写好的函数，有可能别人给你的是编好的库，如果是库文件该如何正确引用和使用呢？

```C++
确保已经有了库文件(.lib静态库或者.dll动态库)以及对应的头文件
1.也需要跟前面的步骤一样正确的包含头文件
    #include "../Include/tinyxml.h"
    
2.分两种情况
    2.1	对于静态库(.lib)而言
    	一、配置库目录：右键 属性->VC++目录，在其右侧的库目录中编辑，例如../fun.lib
		二、配置附加依赖：右键 属性->链接器->输入，在这里输入静态库的名称，例如fun.lib(这里只需要输入静态库名称即可，因为上一步已经配置了静态库路径)
    	也可以不使用上面的方法配置，使用#pragma comment(lib,"../mylib")//直接链接该静态库
    
    
	2.2 对于动态库(.dll)而言
    	动态库文件不需要在项目中添加，因为他是在程序运行时动态链接使用，需要保证程序运行时他们可以被找到
    	一、动态库会有一个对应的静态库，按照2.1正确包含静态库即可  
    	二、将动态库文件放在程序运行目录中：将.dll文件放在可执行文件(.exe)文件相同的目录中，也或者在系统的环境变量中包含.dll文件的路径，将其放在对应路径下
    		放置动态库的三种方法：
    			1.将其放在可执行程序同级目录下
    			2.设置环境变量，在path环境变量下新建一个动态库的目录，将动态库放入这个目录即可
    			3.在程序开始，在代码中调用SetDllDirectory()函数，输入库的路径，也可以临时的告知动态库的路径
    				    // 设置 DLL 搜索路径
                        SetDllDirectory("C:\\path\\to\\your\\dll\\directory");

                        // 你的程序代码

                        // 恢复原来的 DLL 搜索路径（如果需要）
                        SetDllDirectory(NULL);
    				调用该函数需要包含windows头文件 #include <winodws.h>
    	
    
```

编译项目时的生成依赖项选择：

```C++
右键->生成依赖项 -> 项目依赖项：选择一个依赖，什么意思？意思就是编译这个项目的前提需要另一个项目的东西，设置了这个依赖之后vs编译器就可以自动先生成需要的依赖项目，再生成当前项目
```

静态库文件构成：

```C++
当前创建一个mylib的库解决方案，选择静态库模板，vs会自动创建4个文件
    pch.h pch.cpp framework.h mylib.cpp
    pch是有关预编译头的文件，若此时在当前项目中新建头文件，不需要显示的包含该头文件，正常声明函数即可
    
    也就是说，新建库模板之后，再新建一个头文件，然后在该头文件中声明所有的函数，在vs自动创建的cpp也就是mylib.cpp中直接实现这些函数接口即可。整个过程不需要引头文件，因为pch会自动包含头文件
    最后编译生成的库文件名就是创建该库项目时的名字，头文件只需拿有函数接口的那个，若此时想新建另一个cpp写另一些类型的函数，则只需要包含头文件"pch.h"即可
```

动态库的生成

```C++
    在创建的动态库模板中，新建头文件myDll.h，输入：
    #ifdef _BE_OUT_DLL_	//条件编译 当做输出动态库
    #define _LIBRARY_API_ __declspec(dllexport)//
    #else
    #define _LIBRARY_API_ __declspec(dllimport)//
    
    这个就是告诉编译器，是要把当前的动态库项目编译成对外提供接口的动态库，还是需要接口的动态库
    如果定义了_BE_OUT_DLL_这个宏，那么就定义_LIBRARY_API_这个宏为__declspec(dllexport),__declspec(dllexport),__declspec(dllexport)表示当前动态库编译为向外提供接口的动态库，同时生成一个.lib静态库，静态库提供指向动态库
    在头文件中需要对外部接口(类、函数、变量等)用这个宏修饰：
        1.extern "C" _LIBRARY_API_ void myPublicFun();//声明函数
在动态库里定义导出函数为什么要用extern "C"？
    用于禁用C++的名称修饰，因为C++的函数可以重载，虽然我们看到的函数名都是一样的，但是真正内部实现的时候函数名是不一样的，它包含了函数的类型信息描述，会改变函数名。
    假设你有一个 C++ 函数：
	// C++ 代码
	extern "C" void myFunction();
    编译后的名称将不会被修饰，其他语言可以通过这个名字调用这个函数。
如果没有 extern "C"，C++ 编译器会对函数名进行修饰，比如将 myFunction 转换为类似 ?myFunction@@YAXXZ 的名称，这使得 C 或其他语言无法正确找到这个函数。
        
        
        
    	2.class _LIBRARY_API_ myClass{};//声明类
		然后在对应的cpp文件里实现这些接口
            
     注意，需要在cpp里面显式的包含这些接口的头文件，也就是说必须要#include"fun.h"，不然编译不会报错，但是他不会生成对应的.dll静态库文件。
     这个伴随生成的静态库文件提供动态库对外暴露的接口信息等，也为依赖这个库的程序链接到动态库，因为编译的时候需要静态库来告诉编译器有哪些东西，真正运行起来的时候就需要链接到动态库去找具体实现的方法了
            
            
            
        如果编译动态库的时候用的是__declspec(dllimport)代表什么？
            编译动态库的时候不会用到，一般在使用库的某个程序里面会用到，声明某个类、函数或者变量是来自外部动态库的
    
```



编译器指令#pragma

```C++
#pragma message("正在编译Analize.cpp文件！！！！！！！！！！！！！！")
//在编译时输出一条消息到编译器输出窗口。这常用于调试或记录信息。
#pragma comment(lib,"../mylib")//直接链接该静态库
```

**如何将正常的项目编译成静态库**

```C++
不使用vs创建时用的库模板专门创建库，而是将当前正常项目程序编译为库
	编译成静态库：
    右键->属性->常规:将配置类型由exe改为.lib静态库 
        注意！！！！ 库不能存在main函数，编译成库倒是不会报错，但是其他项目依赖该库的时候将会报错：
		错误	LNK2005	main 已经在 callLib.obj 中定义	callLib	E //这表明依赖的库中存在main函数 这个库不能用		
	跟创建静态库模板步骤差不多，尽可能将函数接口写在一个头文件内，函数的实现可以有多个cpp
        
    编译成动态库：
        1.右键->属性->常规:将配置类型由exe改为.dll动态库 
        2.在头文件输入动态库编译宏：
            #ifdef _IS_DLL_
            #define _DLL_API_ __declspec(dllexport)
            #else
            #define _DLL_API_ __declspec(dllimport)
            #include <iostream>
            	...
        注意！！！！ 库不能存在main函数，编译成库倒是不会报错，但是其他项目依赖该库的时候将会报错：
        
```

属性里面各类设置的含义

```C++


C/C++预处理器:
	预处理器定义：可以在这里预定义一个宏，编译的时候编译器就会在这里找宏，比如生成动态库的时候，可以将动态库的哪个宏定义在这里，而不需显示的在代码里定义
VC++目录：
    包含目录：编译器会从这个地方找头文件，也就是说不用在#include""的时候../../inc/类似这样了
    库目录：意义同上，库的目录，不过库还需要在链接器->输入->附加依赖项，在这里写上具体是哪个库
```

